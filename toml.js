// Generated by CoffeeScript 1.5.0
var getVal;

window.TOML = {};

TOML.parse = function(text) {
  var addKey, equalsIndex, isArray, key, keygroup, line, lineNum, obj, processArray, strTokens, val, value, _i, _len, _ref;
  obj = {};
  text = text.replace(/^\s\s*/gm, '').replace(/\s\s*$/gm, '');
  strTokens = [];
  text = text.replace(/"(?:\\[^\n]|[^"\n])*"/g, function(str) {
    str = str.slice(0, str.length - 1).slice(1);
    str = str.replace(/\\n/g, "\n").replace(/\\t/g, "\t").replace(/\\0/g, "\0").replace(/\\r/g, "\r").replace(/\\\\/g, "\\").replace(/\\"/g, "\"");
    strTokens.push(str);
    return "string" + (strTokens.length - 1);
  });
  text = text.replace(/\s*#.*$/gm, "");
  keygroup = obj;
  _ref = text.split("\n");
  for (lineNum = _i = 0, _len = _ref.length; _i < _len; lineNum = ++_i) {
    line = _ref[lineNum];
    if (line === "") {
      continue;
    }
    if (line.match(/^\[[_a-zA-Z](\w|\.)*]$/)) {
      keygroup = obj;
      addKey = function(keys, parent) {
        var key;
        if (keys.length === 0) {
          keygroup = parent;
          return;
        }
        if (!parent) {
          parent = obj;
        }
        key = keys.shift();
        if (!parent[key]) {
          parent[key] = {};
        }
        return addKey(keys, parent[key]);
      };
      addKey(line.replace(/^\[/, "").replace(/]$/, "").split("."), keygroup);
    } else if (!line.match(/^[_a-zA-z]\w*\s*=\s*[string\d|\[\d]|true|false/)) {
      throw "Invalid statement on line " + lineNum;
    } else {
      equalsIndex = line.indexOf("=");
      key = line.slice(0, equalsIndex).replace(/\s*$/, "");
      value = line.slice(equalsIndex + 1).replace(/^\s*/, "");
      if (value.match(isArray = /^\[.*]$/)) {
        processArray = function(arrayStr, parent) {
          var newArray, topArray, val, valueMatch, _ref1, _ref2;
          if (parent == null) {
            parent = null;
          }
          while (!arrayStr.match(/^\s*$/)) {
            arrayStr = arrayStr.replace(/^\s*/, "").replace(/\s*$/, "");
            if (arrayStr[0] === "[") {
              if (parent) {
                newArray = [];
                arrayStr = arrayStr.slice(1);
                _ref1 = processArray(arrayStr, newArray), arrayStr = _ref1[0], newArray = _ref1[1];
                parent.push(newArray);
              } else {
                _ref2 = processArray(arrayStr.slice(1), []), arrayStr = _ref2[0], topArray = _ref2[1];
                return topArray;
              }
            } else if (arrayStr[0] === "]") {
              if (!parent) {
                throw "Could not parse array on line " + lineNum + ". Check for extra ] characters.";
              }
              return [arrayStr.replace(/]\s*,?\s*/, ""), parent];
            } else {
              valueMatch = arrayStr.match(/[^,\]]+/);
              if (!valueMatch) {
                throw "Could not parse array on line " + lineNum + ". Check the number of opening and closing brackets.";
              }
              val = getVal(valueMatch[0].replace(/\s*$/, ""), strTokens);
              if (val == null) {
                debugger;
                throw "Could not parse array on line " + lineNum + ". Check for extra commas.";
              }
              parent.push(val);
              arrayStr = arrayStr.replace(/[^,\]]+/, "");
              if (arrayStr[0] === ",") {
                arrayStr = arrayStr.slice(1);
              }
            }
          }
          throw "Could not parse array on line " + lineNum + ". Check for missing closing brackets.";
        };
        val = processArray(value);
      } else {
        val = getVal(value, strTokens);
        if (val === null) {
          throw "Invalid value with assignment on line " + lineNum;
        }
      }
      keygroup[key] = val;
    }
  }
  return obj;
};

getVal = function(valStr, strTokens) {
  var date;
  if (valStr.match(/^true|false$/)) {
    return /true/.test(valStr);
  } else if (valStr.match(/^-?\d*\.?\d+$/)) {
    return parseFloat(valStr.match(/^\d*\.?\d+$/)[0]);
  } else if (valStr.match(/string\d+/)) {
    return strTokens[parseInt(valStr.match(/\d+/)[0], 10)];
  } else if ((date = new Date(valStr)).toString() !== "Invalid Date") {
    return date;
  }
  return null;
};
